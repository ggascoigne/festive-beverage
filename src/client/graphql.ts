import { useFetchData } from 'client/fetcher'
import { UseMutationOptions, UseQueryOptions, useMutation, useQuery } from 'react-query'

/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
/* eslint-disable @typescript-eslint/ban-types,no-duplicate-imports,etc/prefer-interface */
import { QueryError } from './error'

export type Maybe<T> = T | null
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
/** All built-in and custom scalars, mapped to their actual values */
export interface Scalars {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any
}

/** All input for the create `Role` mutation. */
export interface CreateRoleInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Role` to be created by this mutation. */
  role: RoleInput
}

/** The output of our create `Role` mutation. */
export interface CreateRolePayload {
  __typename: 'CreateRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Role` that was created by this mutation. */
  role?: Maybe<Role>
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>
}

/** The output of our create `Role` mutation. */
export interface CreateRolePayloadRoleEdgeArgs {
  orderBy?: Maybe<Array<RolesOrderBy>>
}

/** All input for the create `User` mutation. */
export interface CreateUserInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `User` to be created by this mutation. */
  user: UserInput
}

/** The output of our create `User` mutation. */
export interface CreateUserPayload {
  __typename: 'CreateUserPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>
}

/** The output of our create `User` mutation. */
export interface CreateUserPayloadUserEdgeArgs {
  orderBy?: Maybe<Array<UsersOrderBy>>
}

/** All input for the create `UserRole` mutation. */
export interface CreateUserRoleInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `UserRole` to be created by this mutation. */
  userRole: UserRoleInput
}

/** The output of our create `UserRole` mutation. */
export interface CreateUserRolePayload {
  __typename: 'CreateUserRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Role` that is related to this `UserRole`. */
  role?: Maybe<Role>
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>
  /** The `UserRole` that was created by this mutation. */
  userRole?: Maybe<UserRole>
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>
}

/** The output of our create `UserRole` mutation. */
export interface CreateUserRolePayloadUserRoleEdgeArgs {
  orderBy?: Maybe<Array<UserRolesOrderBy>>
}

/** All input for the `deleteRoleByAuthority` mutation. */
export interface DeleteRoleByAuthorityInput {
  authority: Scalars['String']
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
}

/** All input for the `deleteRoleByNodeId` mutation. */
export interface DeleteRoleByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Role` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteRole` mutation. */
export interface DeleteRoleInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `Role` mutation. */
export interface DeleteRolePayload {
  __typename: 'DeleteRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedRoleNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Role` that was deleted by this mutation. */
  role?: Maybe<Role>
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>
}

/** The output of our delete `Role` mutation. */
export interface DeleteRolePayloadRoleEdgeArgs {
  orderBy?: Maybe<Array<RolesOrderBy>>
}

/** All input for the `deleteUserByEmail` mutation. */
export interface DeleteUserByEmailInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  email: Scalars['String']
}

/** All input for the `deleteUserByNodeId` mutation. */
export interface DeleteUserByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteUser` mutation. */
export interface DeleteUserInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `User` mutation. */
export interface DeleteUserPayload {
  __typename: 'DeleteUserPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedUserNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>
}

/** The output of our delete `User` mutation. */
export interface DeleteUserPayloadUserEdgeArgs {
  orderBy?: Maybe<Array<UsersOrderBy>>
}

/** All input for the `deleteUserRoleByNodeId` mutation. */
export interface DeleteUserRoleByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `UserRole` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteUserRole` mutation. */
export interface DeleteUserRoleInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  roleId: Scalars['Int']
  userId: Scalars['Int']
}

/** The output of our delete `UserRole` mutation. */
export interface DeleteUserRolePayload {
  __typename: 'DeleteUserRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedUserRoleNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Role` that is related to this `UserRole`. */
  role?: Maybe<Role>
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>
  /** The `UserRole` that was deleted by this mutation. */
  userRole?: Maybe<UserRole>
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>
}

/** The output of our delete `UserRole` mutation. */
export interface DeleteUserRolePayloadUserRoleEdgeArgs {
  orderBy?: Maybe<Array<UserRolesOrderBy>>
}

/** All input for the `fTruncateTables` mutation. */
export interface FTruncateTablesInput {
  _username?: Maybe<Scalars['String']>
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
}

/** The output of our `fTruncateTables` mutation. */
export interface FTruncateTablesPayload {
  __typename: 'FTruncateTablesPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export interface IntFilter {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Int']>
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Int']>
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Int']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Int']>
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Int']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Int']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Int']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Int']>
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Int']>
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Int']>>
}

/** The root mutation type which contains root level fields which mutate data. */
export interface Mutation {
  __typename: 'Mutation'
  /** Creates a single `Role`. */
  createRole?: Maybe<CreateRolePayload>
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>
  /** Creates a single `UserRole`. */
  createUserRole?: Maybe<CreateUserRolePayload>
  /** Deletes a single `Role` using a unique key. */
  deleteRole?: Maybe<DeleteRolePayload>
  /** Deletes a single `Role` using a unique key. */
  deleteRoleByAuthority?: Maybe<DeleteRolePayload>
  /** Deletes a single `Role` using its globally unique id. */
  deleteRoleByNodeId?: Maybe<DeleteRolePayload>
  /** Deletes a single `User` using a unique key. */
  deleteUser?: Maybe<DeleteUserPayload>
  /** Deletes a single `User` using a unique key. */
  deleteUserByEmail?: Maybe<DeleteUserPayload>
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId?: Maybe<DeleteUserPayload>
  /** Deletes a single `UserRole` using a unique key. */
  deleteUserRole?: Maybe<DeleteUserRolePayload>
  /** Deletes a single `UserRole` using its globally unique id. */
  deleteUserRoleByNodeId?: Maybe<DeleteUserRolePayload>
  fTruncateTables?: Maybe<FTruncateTablesPayload>
  /** Updates a single `Role` using a unique key and a patch. */
  updateRole?: Maybe<UpdateRolePayload>
  /** Updates a single `Role` using a unique key and a patch. */
  updateRoleByAuthority?: Maybe<UpdateRolePayload>
  /** Updates a single `Role` using its globally unique id and a patch. */
  updateRoleByNodeId?: Maybe<UpdateRolePayload>
  /** Updates a single `User` using a unique key and a patch. */
  updateUser?: Maybe<UpdateUserPayload>
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByEmail?: Maybe<UpdateUserPayload>
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId?: Maybe<UpdateUserPayload>
  /** Updates a single `UserRole` using a unique key and a patch. */
  updateUserRole?: Maybe<UpdateUserRolePayload>
  /** Updates a single `UserRole` using its globally unique id and a patch. */
  updateUserRoleByNodeId?: Maybe<UpdateUserRolePayload>
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateRoleArgs {
  input: CreateRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateUserArgs {
  input: CreateUserInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateUserRoleArgs {
  input: CreateUserRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteRoleArgs {
  input: DeleteRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteRoleByAuthorityArgs {
  input: DeleteRoleByAuthorityInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteRoleByNodeIdArgs {
  input: DeleteRoleByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteUserArgs {
  input: DeleteUserInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteUserByEmailArgs {
  input: DeleteUserByEmailInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteUserByNodeIdArgs {
  input: DeleteUserByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteUserRoleArgs {
  input: DeleteUserRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteUserRoleByNodeIdArgs {
  input: DeleteUserRoleByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationFTruncateTablesArgs {
  input: FTruncateTablesInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateRoleArgs {
  input: UpdateRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateRoleByAuthorityArgs {
  input: UpdateRoleByAuthorityInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateRoleByNodeIdArgs {
  input: UpdateRoleByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateUserArgs {
  input: UpdateUserInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateUserByEmailArgs {
  input: UpdateUserByEmailInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateUserByNodeIdArgs {
  input: UpdateUserByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateUserRoleArgs {
  input: UpdateUserRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateUserRoleByNodeIdArgs {
  input: UpdateUserRoleByNodeIdInput
}

/** An object with a globally unique `ID`. */
export interface Node {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
}

/** Information about pagination in a connection. */
export interface PageInfo {
  __typename: 'PageInfo'
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>
}

/** The root query type which gives access points into the data universe. */
export interface Query extends Node {
  __typename: 'Query'
  currentUserId?: Maybe<Scalars['Int']>
  currentUserIsAdmin?: Maybe<Scalars['Boolean']>
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID']
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query
  role?: Maybe<Role>
  roleByAuthority?: Maybe<Role>
  /** Reads a single `Role` using its globally unique `ID`. */
  roleByNodeId?: Maybe<Role>
  /** Reads and enables pagination through a set of `Role`. */
  roles?: Maybe<RolesConnection>
  user?: Maybe<User>
  userByEmail?: Maybe<User>
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId?: Maybe<User>
  userRole?: Maybe<UserRole>
  /** Reads a single `UserRole` using its globally unique `ID`. */
  userRoleByNodeId?: Maybe<UserRole>
  /** Reads and enables pagination through a set of `UserRole`. */
  userRoles?: Maybe<UserRolesConnection>
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>
}

/** The root query type which gives access points into the data universe. */
export interface QueryNodeArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryRoleArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryRoleByAuthorityArgs {
  authority: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export interface QueryRoleByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryRolesArgs {
  after?: Maybe<Scalars['Cursor']>
  before?: Maybe<Scalars['Cursor']>
  condition?: Maybe<RoleCondition>
  filter?: Maybe<RoleFilter>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  orderBy?: Maybe<Array<RolesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryUserArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryUserByEmailArgs {
  email: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export interface QueryUserByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryUserRoleArgs {
  roleId: Scalars['Int']
  userId: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryUserRoleByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryUserRolesArgs {
  after?: Maybe<Scalars['Cursor']>
  before?: Maybe<Scalars['Cursor']>
  condition?: Maybe<UserRoleCondition>
  filter?: Maybe<UserRoleFilter>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  orderBy?: Maybe<Array<UserRolesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryUsersArgs {
  after?: Maybe<Scalars['Cursor']>
  before?: Maybe<Scalars['Cursor']>
  condition?: Maybe<UserCondition>
  filter?: Maybe<UserFilter>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  orderBy?: Maybe<Array<UsersOrderBy>>
}

export interface Role extends Node {
  __typename: 'Role'
  authority: Scalars['String']
  id: Scalars['Int']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  /** Reads and enables pagination through a set of `UserRole`. */
  userRoles: UserRolesConnection
}

export interface RoleUserRolesArgs {
  after?: Maybe<Scalars['Cursor']>
  before?: Maybe<Scalars['Cursor']>
  condition?: Maybe<UserRoleCondition>
  filter?: Maybe<UserRoleFilter>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  orderBy?: Maybe<Array<UserRolesOrderBy>>
}

/** A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface RoleCondition {
  /** Checks for equality with the object’s `authority` field. */
  authority?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
}

/** A filter to be used against `Role` object types. All fields are combined with a logical ‘and.’ */
export interface RoleFilter {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<RoleFilter>>
  /** Filter by the object’s `authority` field. */
  authority?: Maybe<StringFilter>
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Negates the expression. */
  not?: Maybe<RoleFilter>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<RoleFilter>>
}

/** An input for mutations affecting `Role` */
export interface RoleInput {
  authority: Scalars['String']
  id?: Maybe<Scalars['Int']>
}

/** Represents an update to a `Role`. Fields that are set will be updated. */
export interface RolePatch {
  authority?: Maybe<Scalars['String']>
  id?: Maybe<Scalars['Int']>
}

/** A connection to a list of `Role` values. */
export interface RolesConnection {
  __typename: 'RolesConnection'
  /** A list of edges which contains the `Role` and cursor to aid in pagination. */
  edges: Array<RolesEdge>
  /** A list of `Role` objects. */
  nodes: Array<Maybe<Role>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Role` edge in the connection. */
export interface RolesEdge {
  __typename: 'RolesEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Role` at the end of the edge. */
  node?: Maybe<Role>
}

/** Methods to use when ordering `Role`. */
export enum RolesOrderBy {
  AuthorityAsc = 'AUTHORITY_ASC',
  AuthorityDesc = 'AUTHORITY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserRolesByRoleIdCountAsc = 'USER_ROLES_BY_ROLE_ID__COUNT_ASC',
  UserRolesByRoleIdCountDesc = 'USER_ROLES_BY_ROLE_ID__COUNT_DESC',
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export interface StringFilter {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['String']>
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: Maybe<Scalars['String']>
  /** Ends with the specified string (case-sensitive). */
  endsWith?: Maybe<Scalars['String']>
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: Maybe<Scalars['String']>
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: Maybe<Scalars['String']>
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: Maybe<Scalars['String']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: Maybe<Scalars['String']>
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['String']>>
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: Maybe<Array<Scalars['String']>>
  /** Contains the specified string (case-sensitive). */
  includes?: Maybe<Scalars['String']>
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: Maybe<Scalars['String']>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: Maybe<Scalars['String']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: Maybe<Scalars['String']>
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: Maybe<Scalars['String']>
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: Maybe<Scalars['String']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['String']>
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: Maybe<Scalars['String']>
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: Maybe<Scalars['String']>
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: Maybe<Scalars['String']>
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: Maybe<Scalars['String']>
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['String']>>
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: Maybe<Array<Scalars['String']>>
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: Maybe<Scalars['String']>
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: Maybe<Scalars['String']>
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: Maybe<Scalars['String']>
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: Maybe<Scalars['String']>
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: Maybe<Scalars['String']>
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: Maybe<Scalars['String']>
  /** Starts with the specified string (case-sensitive). */
  startsWith?: Maybe<Scalars['String']>
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: Maybe<Scalars['String']>
}

/** All input for the `updateRoleByAuthority` mutation. */
export interface UpdateRoleByAuthorityInput {
  authority: Scalars['String']
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch
}

/** All input for the `updateRoleByNodeId` mutation. */
export interface UpdateRoleByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Role` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch
}

/** All input for the `updateRole` mutation. */
export interface UpdateRoleInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch
}

/** The output of our update `Role` mutation. */
export interface UpdateRolePayload {
  __typename: 'UpdateRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Role` that was updated by this mutation. */
  role?: Maybe<Role>
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>
}

/** The output of our update `Role` mutation. */
export interface UpdateRolePayloadRoleEdgeArgs {
  orderBy?: Maybe<Array<RolesOrderBy>>
}

/** All input for the `updateUserByEmail` mutation. */
export interface UpdateUserByEmailInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  email: Scalars['String']
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch
}

/** All input for the `updateUserByNodeId` mutation. */
export interface UpdateUserByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch
}

/** All input for the `updateUser` mutation. */
export interface UpdateUserInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch
}

/** The output of our update `User` mutation. */
export interface UpdateUserPayload {
  __typename: 'UpdateUserPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>
}

/** The output of our update `User` mutation. */
export interface UpdateUserPayloadUserEdgeArgs {
  orderBy?: Maybe<Array<UsersOrderBy>>
}

/** All input for the `updateUserRoleByNodeId` mutation. */
export interface UpdateUserRoleByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `UserRole` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `UserRole` being updated. */
  patch: UserRolePatch
}

/** All input for the `updateUserRole` mutation. */
export interface UpdateUserRoleInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `UserRole` being updated. */
  patch: UserRolePatch
  roleId: Scalars['Int']
  userId: Scalars['Int']
}

/** The output of our update `UserRole` mutation. */
export interface UpdateUserRolePayload {
  __typename: 'UpdateUserRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Role` that is related to this `UserRole`. */
  role?: Maybe<Role>
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>
  /** The `UserRole` that was updated by this mutation. */
  userRole?: Maybe<UserRole>
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>
}

/** The output of our update `UserRole` mutation. */
export interface UpdateUserRolePayloadUserRoleEdgeArgs {
  orderBy?: Maybe<Array<UserRolesOrderBy>>
}

export interface User extends Node {
  __typename: 'User'
  email: Scalars['String']
  id: Scalars['Int']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  /** Reads and enables pagination through a set of `UserRole`. */
  userRoles: UserRolesConnection
}

export interface UserUserRolesArgs {
  after?: Maybe<Scalars['Cursor']>
  before?: Maybe<Scalars['Cursor']>
  condition?: Maybe<UserRoleCondition>
  filter?: Maybe<UserRoleFilter>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  orderBy?: Maybe<Array<UserRolesOrderBy>>
}

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface UserCondition {
  /** Checks for equality with the object’s `email` field. */
  email?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
}

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export interface UserFilter {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserFilter>>
  /** Filter by the object’s `email` field. */
  email?: Maybe<StringFilter>
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Negates the expression. */
  not?: Maybe<UserFilter>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserFilter>>
}

/** An input for mutations affecting `User` */
export interface UserInput {
  email: Scalars['String']
  id?: Maybe<Scalars['Int']>
}

/** Represents an update to a `User`. Fields that are set will be updated. */
export interface UserPatch {
  email?: Maybe<Scalars['String']>
  id?: Maybe<Scalars['Int']>
}

export interface UserRole extends Node {
  __typename: 'UserRole'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  /** Reads a single `Role` that is related to this `UserRole`. */
  role?: Maybe<Role>
  roleId: Scalars['Int']
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>
  userId: Scalars['Int']
}

/**
 * A condition to be used against `UserRole` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export interface UserRoleCondition {
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>
}

/** A filter to be used against `UserRole` object types. All fields are combined with a logical ‘and.’ */
export interface UserRoleFilter {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserRoleFilter>>
  /** Negates the expression. */
  not?: Maybe<UserRoleFilter>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserRoleFilter>>
  /** Filter by the object’s `roleId` field. */
  roleId?: Maybe<IntFilter>
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>
}

/** An input for mutations affecting `UserRole` */
export interface UserRoleInput {
  roleId: Scalars['Int']
  userId: Scalars['Int']
}

/** Represents an update to a `UserRole`. Fields that are set will be updated. */
export interface UserRolePatch {
  roleId?: Maybe<Scalars['Int']>
  userId?: Maybe<Scalars['Int']>
}

/** A connection to a list of `UserRole` values. */
export interface UserRolesConnection {
  __typename: 'UserRolesConnection'
  /** A list of edges which contains the `UserRole` and cursor to aid in pagination. */
  edges: Array<UserRolesEdge>
  /** A list of `UserRole` objects. */
  nodes: Array<Maybe<UserRole>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `UserRole` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `UserRole` edge in the connection. */
export interface UserRolesEdge {
  __typename: 'UserRolesEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `UserRole` at the end of the edge. */
  node?: Maybe<UserRole>
}

/** Methods to use when ordering `UserRole`. */
export enum UserRolesOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleByRoleIdAuthorityAsc = 'ROLE_BY_ROLE_ID__AUTHORITY_ASC',
  RoleByRoleIdAuthorityDesc = 'ROLE_BY_ROLE_ID__AUTHORITY_DESC',
  RoleByRoleIdIdAsc = 'ROLE_BY_ROLE_ID__ID_ASC',
  RoleByRoleIdIdDesc = 'ROLE_BY_ROLE_ID__ID_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
}

/** A connection to a list of `User` values. */
export interface UsersConnection {
  __typename: 'UsersConnection'
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `User` edge in the connection. */
export interface UsersEdge {
  __typename: 'UsersEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `User` at the end of the edge. */
  node?: Maybe<User>
}

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserRolesByUserIdCountAsc = 'USER_ROLES_BY_USER_ID__COUNT_ASC',
  UserRolesByUserIdCountDesc = 'USER_ROLES_BY_USER_ID__COUNT_DESC',
}

export type GetUserByEmailQueryVariables = Exact<{
  email: Scalars['String']
}>

export type GetUserByEmailQuery = {
  __typename: 'Query'
  userByEmail?: Maybe<{ __typename: 'User'; id: number; email: string }>
}

export type GetUserByIdQueryVariables = Exact<{
  id: Scalars['Int']
}>

export type GetUserByIdQuery = { __typename: 'Query'; user?: Maybe<{ __typename: 'User'; id: number; email: string }> }

export type UpdateUserMutationVariables = Exact<{
  input: UpdateUserInput
}>

export type UpdateUserMutation = {
  __typename: 'Mutation'
  updateUser?: Maybe<{
    __typename: 'UpdateUserPayload'
    user?: Maybe<{ __typename: 'User'; id: number; email: string }>
  }>
}

export type GetAllUsersQueryVariables = Exact<{ [key: string]: never }>

export type GetAllUsersQuery = {
  __typename: 'Query'
  users?: Maybe<{
    __typename: 'UsersConnection'
    nodes: Array<Maybe<{ __typename: 'User'; id: number; email: string }>>
  }>
}

export type UserFieldsFragment = { __typename: 'User'; id: number; email: string }

export const UserFieldsFragmentDoc = `
    fragment userFields on User {
  id
  email
}
    `
export const GetUserByEmailDocument = `
    query getUserByEmail($email: String!) {
  userByEmail(email: $email) {
    ...userFields
  }
}
    ${UserFieldsFragmentDoc}`
export const useGetUserByEmailQuery = <TData = GetUserByEmailQuery, TError = QueryError>(
  variables: GetUserByEmailQueryVariables,
  options?: UseQueryOptions<GetUserByEmailQuery, TError, TData>
) =>
  useQuery<GetUserByEmailQuery, TError, TData>(
    ['getUserByEmail', variables],
    useFetchData<GetUserByEmailQuery, GetUserByEmailQueryVariables>(GetUserByEmailDocument).bind(null, variables),
    options
  )
export const GetUserByIdDocument = `
    query getUserById($id: Int!) {
  user(id: $id) {
    ...userFields
  }
}
    ${UserFieldsFragmentDoc}`
export const useGetUserByIdQuery = <TData = GetUserByIdQuery, TError = QueryError>(
  variables: GetUserByIdQueryVariables,
  options?: UseQueryOptions<GetUserByIdQuery, TError, TData>
) =>
  useQuery<GetUserByIdQuery, TError, TData>(
    ['getUserById', variables],
    useFetchData<GetUserByIdQuery, GetUserByIdQueryVariables>(GetUserByIdDocument).bind(null, variables),
    options
  )
export const UpdateUserDocument = `
    mutation updateUser($input: UpdateUserInput!) {
  updateUser(input: $input) {
    user {
      ...userFields
    }
  }
}
    ${UserFieldsFragmentDoc}`
export const useUpdateUserMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<UpdateUserMutation, TError, UpdateUserMutationVariables, TContext>
) =>
  useMutation<UpdateUserMutation, TError, UpdateUserMutationVariables, TContext>(
    useFetchData<UpdateUserMutation, UpdateUserMutationVariables>(UpdateUserDocument),
    options
  )
export const GetAllUsersDocument = `
    query getAllUsers {
  users {
    nodes {
      ...userFields
    }
  }
}
    ${UserFieldsFragmentDoc}`
export const useGetAllUsersQuery = <TData = GetAllUsersQuery, TError = QueryError>(
  variables?: GetAllUsersQueryVariables,
  options?: UseQueryOptions<GetAllUsersQuery, TError, TData>
) =>
  useQuery<GetAllUsersQuery, TError, TData>(
    variables === undefined ? ['getAllUsers'] : ['getAllUsers', variables],
    useFetchData<GetAllUsersQuery, GetAllUsersQueryVariables>(GetAllUsersDocument).bind(null, variables),
    options
  )
